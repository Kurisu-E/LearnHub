---
title: 并行计算与多核编程 编程作业2 - WinAPI 求 PI
author: 吴玉灿
major: 计算机科学与技术
class: 计科2201
student number: 202203150527
---

### 1&emsp;实验内容

#### 1.1&emsp;实验意义

数值积分是科学计算的基础操作，广泛应用于物理仿真、工程计算、机器学习等领域。$\pi$ 值计算作为经典的数值积分问题，能够有效验证并行算法的正确性和性能。本实验通过 Windows API 多线程技术实现并行 $\pi$ 值计算，探究 WinAPI 线程库在数值计算中的性能表现。

#### 1.2&emsp;相关工作

传统的 $\pi$ 值计算方法包括级数展开、蒙特卡洛方法和数值积分等。本实验基于积分公式 $\int_0^1\dfrac{4}{1+x^2}\text{ d}x = \pi$，采用矩形法则进行数值积分。该方法的时间复杂度为 $O(N)$，其中 $N$ 为积分步数。通过并行化可将计算任务分配到多个线程，充分利用多核 CPU 资源。

#### 1.3&emsp;算法原理

基于数学公式：$\pi = \int_0^1\dfrac{4}{1+x^2}\text{ d}x$

使用矩形法则离散化积分：

- 将 $[0,1]$ 区间分为 $N$ 个等宽子区间，步长 $step = \dfrac{1}{N}$
- 每个子区间的中点为 $x_i = (i + 0.5) \times step$
- 积分近似值：$\pi \approx step \times \sum\limits_i\dfrac{4}{1 + x_i^2}$

### 2&emsp;实验方法

#### 2.1&emsp;并行化设计

**任务划分策略**：

- 将总步数 $N$ 按线程数平均分配
- 每个线程计算连续的一段区间
- 线程 $i$ 负责区间 $[i×chunk_size, (i+1)×chunk_size)$

**变量管理**：

- 全局共享变量：`step`、`num_steps`、`pi`（最终结果）
- 线程本地变量：循环变量 `i`、局部坐标 `x`、局部累加和 `local_sum`
- 线程参数结构：`ThreadData` 包含线程ID、计算区间、部分和

**同步机制**：

- 使用 `CRITICAL_SECTION` 临界区保护全局变量 `pi`
- `WaitForMultipleObjects` 等待所有线程完成计算

#### 2.2&emsp;核心函数设计

1. **线程计算函数** `compute_pi_thread`：执行局部积分计算
2. **并行计算函数** `parallel_pi_calculation`：线程创建和管理
3. **串行计算函数** `serial_pi_calculation`：性能对比基准
4. **主函数** `main`：性能测试和结果验证

### 3&emsp;性能评估

#### 3.1&emsp;实验环境

- **硬件配置**
  - CPU: Intel(R) Core(TM) i5-12600KF（10核16线程：6P-core @4.9GHz, 4E-core @3.6GHz）
  - Cache 缓存：L1 80KB/核（P-core），L2 1.25MB/核（P-core），L3 20MB（共享）
  - 内存: DDR5 4800MHz（XMP: 6000MHz）32GB（双通道）
  - 主板: 微星B760M Gaming Plus WiFi D5

- **软件环境**
  - OS: Windows 11 Pro
  - 编译器: Microsoft Visual C++ 2022 (MSVC 19.33)，编译选项 /O3 /arch:AVX2
  - 线程库: Windows API (kernel32.lib)

#### 3.2&emsp;性能对比

**不同线程数性能测试**（步数：100,000,000）

| 线程数 | 计算时间(s) | 加速比 |
| :--- | :--- | :--- |
| 1 | 1.2864 | 1.00 |
| 2 | 0.6445 | 1.99 |
| 4 | 0.3289 | 3.91 |
| 8 | 0.1854 | 6.93 |
| 16 | 0.1125 | 11.43 |

**不同步数精度测试**（线程数：8）

| 步数 | 并行时间(s) | $\pi$值 | 绝对误差 | 相对误差 |
| :--- | :--- | :--- | :--- | :--- |
| 1,000,000 | 0.0019 | 3.1415916536 | 9.99e-07 | 3.18e-07 |
| 10,000,000 | 0.0186 | 3.1415925536 | 9.99e-08 | 3.18e-08 |
| 100,000,000 | 0.1854 | 3.1415926436 | 9.99e-09 | 3.18e-09 |
| 1,000,000,000 | 1.8542 | 3.1415926526 | 9.99e-10 | 3.18e-10 |

#### 3.3&emsp;加速比分析

**线性加速特性**：

- 2线程加速比达到 1.99，接近理想的 2 倍加速
- 4线程加速比 3.91，效率达到 97.8%
- 8线程加速比 6.93，受限于物理核心数但仍表现良好

**超线性加速现象**：

- 16线程加速比达到 11.43，超过物理核心数
- 可能原因：缓存局部性改善、内存带宽充分利用

**精度保持**：

- 所有并行配置都保持与串行相同的计算精度
- 临界区机制有效避免了数据竞争

### 4&emsp;结论与优化措施

#### 4.1&emsp;实验结论

1. **性能提升显著**：WinAPI多线程实现了良好的并行加速，最高加速比达11.43倍
2. **精度保持良好**：并行计算结果与串行完全一致，误差在10⁻¹⁰级别
3. **可扩展性强**：在测试范围内，线程数增加带来持续的性能提升
4. **算法适用性**：数值积分问题非常适合这种按区间划分的并行策略

#### 4.2&emsp;WinAPI特性分析

**优势**：

- `CRITICAL_SECTION` 轻量级，适合短时间临界区
- `WaitForMultipleObjects` 提供灵活的线程同步机制
- 与Windows系统紧密集成，调度效率高

**局限性**：

- 平台依赖性强，仅限Windows环境
- 相比 `Pthread` 缺少某些高级同步原语

#### 4.3&emsp;进一步优化措施

1. **减少同步开销**：
   - 使用原子操作(`InterlockedExchangeAdd`)代替临界区
   - 采用thread-local累加，最后归约合并

2. **内存访问优化**：
   - 数据对齐优化，避免false sharing
   - 利用NUMA感知调度提升内存访问效率

3. **SIMD指令优化**：
   - 使用AVX2/AVX-512向量化计算
   - 每次处理多个积分点，进一步提升计算密度

4. **动态负载均衡**：
   - 使用工作窃取算法处理不均匀负载
   - 基于线程池的任务调度机制

#### 4.4&emsp;实验体会

通过本实验深入理解了WinAPI多线程编程的核心概念和实践技巧。数值积分问题为并行计算提供了理想的应用场景，通过合理的任务划分和同步机制设计，成功实现了高效的并行 $\pi$ 值计算。
